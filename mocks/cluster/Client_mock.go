// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package cluster

import (
	"context"
	"io"

	"github.com/akash-network/provider/cluster/types/v1beta3"
	"github.com/akash-network/provider/cluster/types/v1beta3/clients/hostname"
	"github.com/akash-network/provider/cluster/types/v1beta3/clients/ip"
	"github.com/akash-network/provider/pkg/apis/akash.network/v2beta2"
	mock "github.com/stretchr/testify/mock"
	"k8s.io/apimachinery/pkg/version"
	"k8s.io/client-go/tools/remotecommand"
	"pkg.akt.dev/go/manifest/v2beta3"
	"pkg.akt.dev/go/node/market/v1"
	"pkg.akt.dev/go/provider/client"
)

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// AllHostnames provides a mock function for the type Client
func (_mock *Client) AllHostnames(context1 context.Context) ([]hostname.ActiveHostname, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for AllHostnames")
	}

	var r0 []hostname.ActiveHostname
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]hostname.ActiveHostname, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []hostname.ActiveHostname); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]hostname.ActiveHostname)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_AllHostnames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllHostnames'
type Client_AllHostnames_Call struct {
	*mock.Call
}

// AllHostnames is a helper method to define mock.On call
//   - context1 context.Context
func (_e *Client_Expecter) AllHostnames(context1 interface{}) *Client_AllHostnames_Call {
	return &Client_AllHostnames_Call{Call: _e.mock.On("AllHostnames", context1)}
}

func (_c *Client_AllHostnames_Call) Run(run func(context1 context.Context)) *Client_AllHostnames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_AllHostnames_Call) Return(activeHostnames []hostname.ActiveHostname, err error) *Client_AllHostnames_Call {
	_c.Call.Return(activeHostnames, err)
	return _c
}

func (_c *Client_AllHostnames_Call) RunAndReturn(run func(context1 context.Context) ([]hostname.ActiveHostname, error)) *Client_AllHostnames_Call {
	_c.Call.Return(run)
	return _c
}

// ConnectHostnameToDeployment provides a mock function for the type Client
func (_mock *Client) ConnectHostnameToDeployment(ctx context.Context, directive hostname.ConnectToDeploymentDirective) error {
	ret := _mock.Called(ctx, directive)

	if len(ret) == 0 {
		panic("no return value specified for ConnectHostnameToDeployment")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, hostname.ConnectToDeploymentDirective) error); ok {
		r0 = returnFunc(ctx, directive)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_ConnectHostnameToDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectHostnameToDeployment'
type Client_ConnectHostnameToDeployment_Call struct {
	*mock.Call
}

// ConnectHostnameToDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - directive hostname.ConnectToDeploymentDirective
func (_e *Client_Expecter) ConnectHostnameToDeployment(ctx interface{}, directive interface{}) *Client_ConnectHostnameToDeployment_Call {
	return &Client_ConnectHostnameToDeployment_Call{Call: _e.mock.On("ConnectHostnameToDeployment", ctx, directive)}
}

func (_c *Client_ConnectHostnameToDeployment_Call) Run(run func(ctx context.Context, directive hostname.ConnectToDeploymentDirective)) *Client_ConnectHostnameToDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 hostname.ConnectToDeploymentDirective
		if args[1] != nil {
			arg1 = args[1].(hostname.ConnectToDeploymentDirective)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_ConnectHostnameToDeployment_Call) Return(err error) *Client_ConnectHostnameToDeployment_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_ConnectHostnameToDeployment_Call) RunAndReturn(run func(ctx context.Context, directive hostname.ConnectToDeploymentDirective) error) *Client_ConnectHostnameToDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// DeclareHostname provides a mock function for the type Client
func (_mock *Client) DeclareHostname(ctx context.Context, lID v1.LeaseID, host string, serviceName string, externalPort uint32) error {
	ret := _mock.Called(ctx, lID, host, serviceName, externalPort)

	if len(ret) == 0 {
		panic("no return value specified for DeclareHostname")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, string, uint32) error); ok {
		r0 = returnFunc(ctx, lID, host, serviceName, externalPort)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_DeclareHostname_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeclareHostname'
type Client_DeclareHostname_Call struct {
	*mock.Call
}

// DeclareHostname is a helper method to define mock.On call
//   - ctx context.Context
//   - lID v1.LeaseID
//   - host string
//   - serviceName string
//   - externalPort uint32
func (_e *Client_Expecter) DeclareHostname(ctx interface{}, lID interface{}, host interface{}, serviceName interface{}, externalPort interface{}) *Client_DeclareHostname_Call {
	return &Client_DeclareHostname_Call{Call: _e.mock.On("DeclareHostname", ctx, lID, host, serviceName, externalPort)}
}

func (_c *Client_DeclareHostname_Call) Run(run func(ctx context.Context, lID v1.LeaseID, host string, serviceName string, externalPort uint32)) *Client_DeclareHostname_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 uint32
		if args[4] != nil {
			arg4 = args[4].(uint32)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *Client_DeclareHostname_Call) Return(err error) *Client_DeclareHostname_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_DeclareHostname_Call) RunAndReturn(run func(ctx context.Context, lID v1.LeaseID, host string, serviceName string, externalPort uint32) error) *Client_DeclareHostname_Call {
	_c.Call.Return(run)
	return _c
}

// DeclareIP provides a mock function for the type Client
func (_mock *Client) DeclareIP(ctx context.Context, lID v1.LeaseID, serviceName string, port uint32, externalPort uint32, proto v2beta3.ServiceProtocol, sharingKey string, overwrite bool) error {
	ret := _mock.Called(ctx, lID, serviceName, port, externalPort, proto, sharingKey, overwrite)

	if len(ret) == 0 {
		panic("no return value specified for DeclareIP")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, uint32, uint32, v2beta3.ServiceProtocol, string, bool) error); ok {
		r0 = returnFunc(ctx, lID, serviceName, port, externalPort, proto, sharingKey, overwrite)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_DeclareIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeclareIP'
type Client_DeclareIP_Call struct {
	*mock.Call
}

// DeclareIP is a helper method to define mock.On call
//   - ctx context.Context
//   - lID v1.LeaseID
//   - serviceName string
//   - port uint32
//   - externalPort uint32
//   - proto v2beta3.ServiceProtocol
//   - sharingKey string
//   - overwrite bool
func (_e *Client_Expecter) DeclareIP(ctx interface{}, lID interface{}, serviceName interface{}, port interface{}, externalPort interface{}, proto interface{}, sharingKey interface{}, overwrite interface{}) *Client_DeclareIP_Call {
	return &Client_DeclareIP_Call{Call: _e.mock.On("DeclareIP", ctx, lID, serviceName, port, externalPort, proto, sharingKey, overwrite)}
}

func (_c *Client_DeclareIP_Call) Run(run func(ctx context.Context, lID v1.LeaseID, serviceName string, port uint32, externalPort uint32, proto v2beta3.ServiceProtocol, sharingKey string, overwrite bool)) *Client_DeclareIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 uint32
		if args[3] != nil {
			arg3 = args[3].(uint32)
		}
		var arg4 uint32
		if args[4] != nil {
			arg4 = args[4].(uint32)
		}
		var arg5 v2beta3.ServiceProtocol
		if args[5] != nil {
			arg5 = args[5].(v2beta3.ServiceProtocol)
		}
		var arg6 string
		if args[6] != nil {
			arg6 = args[6].(string)
		}
		var arg7 bool
		if args[7] != nil {
			arg7 = args[7].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
		)
	})
	return _c
}

func (_c *Client_DeclareIP_Call) Return(err error) *Client_DeclareIP_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_DeclareIP_Call) RunAndReturn(run func(ctx context.Context, lID v1.LeaseID, serviceName string, port uint32, externalPort uint32, proto v2beta3.ServiceProtocol, sharingKey string, overwrite bool) error) *Client_DeclareIP_Call {
	_c.Call.Return(run)
	return _c
}

// Deploy provides a mock function for the type Client
func (_mock *Client) Deploy(ctx context.Context, deployment v1beta3.IDeployment) error {
	ret := _mock.Called(ctx, deployment)

	if len(ret) == 0 {
		panic("no return value specified for Deploy")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1beta3.IDeployment) error); ok {
		r0 = returnFunc(ctx, deployment)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_Deploy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Deploy'
type Client_Deploy_Call struct {
	*mock.Call
}

// Deploy is a helper method to define mock.On call
//   - ctx context.Context
//   - deployment v1beta3.IDeployment
func (_e *Client_Expecter) Deploy(ctx interface{}, deployment interface{}) *Client_Deploy_Call {
	return &Client_Deploy_Call{Call: _e.mock.On("Deploy", ctx, deployment)}
}

func (_c *Client_Deploy_Call) Run(run func(ctx context.Context, deployment v1beta3.IDeployment)) *Client_Deploy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1beta3.IDeployment
		if args[1] != nil {
			arg1 = args[1].(v1beta3.IDeployment)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_Deploy_Call) Return(err error) *Client_Deploy_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_Deploy_Call) RunAndReturn(run func(ctx context.Context, deployment v1beta3.IDeployment) error) *Client_Deploy_Call {
	_c.Call.Return(run)
	return _c
}

// Deployments provides a mock function for the type Client
func (_mock *Client) Deployments(context1 context.Context) ([]v1beta3.IDeployment, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Deployments")
	}

	var r0 []v1beta3.IDeployment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]v1beta3.IDeployment, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []v1beta3.IDeployment); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1beta3.IDeployment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Deployments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Deployments'
type Client_Deployments_Call struct {
	*mock.Call
}

// Deployments is a helper method to define mock.On call
//   - context1 context.Context
func (_e *Client_Expecter) Deployments(context1 interface{}) *Client_Deployments_Call {
	return &Client_Deployments_Call{Call: _e.mock.On("Deployments", context1)}
}

func (_c *Client_Deployments_Call) Run(run func(context1 context.Context)) *Client_Deployments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Deployments_Call) Return(iDeployments []v1beta3.IDeployment, err error) *Client_Deployments_Call {
	_c.Call.Return(iDeployments, err)
	return _c
}

func (_c *Client_Deployments_Call) RunAndReturn(run func(context1 context.Context) ([]v1beta3.IDeployment, error)) *Client_Deployments_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function for the type Client
func (_mock *Client) Exec(ctx context.Context, lID v1.LeaseID, service string, podIndex uint, cmd []string, stdin io.Reader, stdout io.Writer, stderr io.Writer, tty bool, tsq remotecommand.TerminalSizeQueue) (v1beta3.ExecResult, error) {
	ret := _mock.Called(ctx, lID, service, podIndex, cmd, stdin, stdout, stderr, tty, tsq)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 v1beta3.ExecResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, uint, []string, io.Reader, io.Writer, io.Writer, bool, remotecommand.TerminalSizeQueue) (v1beta3.ExecResult, error)); ok {
		return returnFunc(ctx, lID, service, podIndex, cmd, stdin, stdout, stderr, tty, tsq)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, uint, []string, io.Reader, io.Writer, io.Writer, bool, remotecommand.TerminalSizeQueue) v1beta3.ExecResult); ok {
		r0 = returnFunc(ctx, lID, service, podIndex, cmd, stdin, stdout, stderr, tty, tsq)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1beta3.ExecResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID, string, uint, []string, io.Reader, io.Writer, io.Writer, bool, remotecommand.TerminalSizeQueue) error); ok {
		r1 = returnFunc(ctx, lID, service, podIndex, cmd, stdin, stdout, stderr, tty, tsq)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type Client_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - lID v1.LeaseID
//   - service string
//   - podIndex uint
//   - cmd []string
//   - stdin io.Reader
//   - stdout io.Writer
//   - stderr io.Writer
//   - tty bool
//   - tsq remotecommand.TerminalSizeQueue
func (_e *Client_Expecter) Exec(ctx interface{}, lID interface{}, service interface{}, podIndex interface{}, cmd interface{}, stdin interface{}, stdout interface{}, stderr interface{}, tty interface{}, tsq interface{}) *Client_Exec_Call {
	return &Client_Exec_Call{Call: _e.mock.On("Exec", ctx, lID, service, podIndex, cmd, stdin, stdout, stderr, tty, tsq)}
}

func (_c *Client_Exec_Call) Run(run func(ctx context.Context, lID v1.LeaseID, service string, podIndex uint, cmd []string, stdin io.Reader, stdout io.Writer, stderr io.Writer, tty bool, tsq remotecommand.TerminalSizeQueue)) *Client_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 uint
		if args[3] != nil {
			arg3 = args[3].(uint)
		}
		var arg4 []string
		if args[4] != nil {
			arg4 = args[4].([]string)
		}
		var arg5 io.Reader
		if args[5] != nil {
			arg5 = args[5].(io.Reader)
		}
		var arg6 io.Writer
		if args[6] != nil {
			arg6 = args[6].(io.Writer)
		}
		var arg7 io.Writer
		if args[7] != nil {
			arg7 = args[7].(io.Writer)
		}
		var arg8 bool
		if args[8] != nil {
			arg8 = args[8].(bool)
		}
		var arg9 remotecommand.TerminalSizeQueue
		if args[9] != nil {
			arg9 = args[9].(remotecommand.TerminalSizeQueue)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
			arg8,
			arg9,
		)
	})
	return _c
}

func (_c *Client_Exec_Call) Return(execResult v1beta3.ExecResult, err error) *Client_Exec_Call {
	_c.Call.Return(execResult, err)
	return _c
}

func (_c *Client_Exec_Call) RunAndReturn(run func(ctx context.Context, lID v1.LeaseID, service string, podIndex uint, cmd []string, stdin io.Reader, stdout io.Writer, stderr io.Writer, tty bool, tsq remotecommand.TerminalSizeQueue) (v1beta3.ExecResult, error)) *Client_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// ForwardedPortStatus provides a mock function for the type Client
func (_mock *Client) ForwardedPortStatus(context1 context.Context, leaseID v1.LeaseID) (map[string][]rest.ForwardedPortStatus, error) {
	ret := _mock.Called(context1, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for ForwardedPortStatus")
	}

	var r0 map[string][]rest.ForwardedPortStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) (map[string][]rest.ForwardedPortStatus, error)); ok {
		return returnFunc(context1, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) map[string][]rest.ForwardedPortStatus); ok {
		r0 = returnFunc(context1, leaseID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]rest.ForwardedPortStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) error); ok {
		r1 = returnFunc(context1, leaseID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ForwardedPortStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForwardedPortStatus'
type Client_ForwardedPortStatus_Call struct {
	*mock.Call
}

// ForwardedPortStatus is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
func (_e *Client_Expecter) ForwardedPortStatus(context1 interface{}, leaseID interface{}) *Client_ForwardedPortStatus_Call {
	return &Client_ForwardedPortStatus_Call{Call: _e.mock.On("ForwardedPortStatus", context1, leaseID)}
}

func (_c *Client_ForwardedPortStatus_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID)) *Client_ForwardedPortStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_ForwardedPortStatus_Call) Return(stringToForwardedPortStatuss map[string][]rest.ForwardedPortStatus, err error) *Client_ForwardedPortStatus_Call {
	_c.Call.Return(stringToForwardedPortStatuss, err)
	return _c
}

func (_c *Client_ForwardedPortStatus_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID) (map[string][]rest.ForwardedPortStatus, error)) *Client_ForwardedPortStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeclaredIPs provides a mock function for the type Client
func (_mock *Client) GetDeclaredIPs(ctx context.Context, leaseID v1.LeaseID) ([]v2beta2.ProviderLeasedIPSpec, error) {
	ret := _mock.Called(ctx, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for GetDeclaredIPs")
	}

	var r0 []v2beta2.ProviderLeasedIPSpec
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) ([]v2beta2.ProviderLeasedIPSpec, error)); ok {
		return returnFunc(ctx, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) []v2beta2.ProviderLeasedIPSpec); ok {
		r0 = returnFunc(ctx, leaseID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v2beta2.ProviderLeasedIPSpec)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) error); ok {
		r1 = returnFunc(ctx, leaseID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetDeclaredIPs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeclaredIPs'
type Client_GetDeclaredIPs_Call struct {
	*mock.Call
}

// GetDeclaredIPs is a helper method to define mock.On call
//   - ctx context.Context
//   - leaseID v1.LeaseID
func (_e *Client_Expecter) GetDeclaredIPs(ctx interface{}, leaseID interface{}) *Client_GetDeclaredIPs_Call {
	return &Client_GetDeclaredIPs_Call{Call: _e.mock.On("GetDeclaredIPs", ctx, leaseID)}
}

func (_c *Client_GetDeclaredIPs_Call) Run(run func(ctx context.Context, leaseID v1.LeaseID)) *Client_GetDeclaredIPs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetDeclaredIPs_Call) Return(providerLeasedIPSpecs []v2beta2.ProviderLeasedIPSpec, err error) *Client_GetDeclaredIPs_Call {
	_c.Call.Return(providerLeasedIPSpecs, err)
	return _c
}

func (_c *Client_GetDeclaredIPs_Call) RunAndReturn(run func(ctx context.Context, leaseID v1.LeaseID) ([]v2beta2.ProviderLeasedIPSpec, error)) *Client_GetDeclaredIPs_Call {
	_c.Call.Return(run)
	return _c
}

// GetHostnameDeploymentConnections provides a mock function for the type Client
func (_mock *Client) GetHostnameDeploymentConnections(ctx context.Context) ([]hostname.LeaseIDConnection, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetHostnameDeploymentConnections")
	}

	var r0 []hostname.LeaseIDConnection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]hostname.LeaseIDConnection, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []hostname.LeaseIDConnection); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]hostname.LeaseIDConnection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetHostnameDeploymentConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostnameDeploymentConnections'
type Client_GetHostnameDeploymentConnections_Call struct {
	*mock.Call
}

// GetHostnameDeploymentConnections is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetHostnameDeploymentConnections(ctx interface{}) *Client_GetHostnameDeploymentConnections_Call {
	return &Client_GetHostnameDeploymentConnections_Call{Call: _e.mock.On("GetHostnameDeploymentConnections", ctx)}
}

func (_c *Client_GetHostnameDeploymentConnections_Call) Run(run func(ctx context.Context)) *Client_GetHostnameDeploymentConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_GetHostnameDeploymentConnections_Call) Return(leaseIDConnections []hostname.LeaseIDConnection, err error) *Client_GetHostnameDeploymentConnections_Call {
	_c.Call.Return(leaseIDConnections, err)
	return _c
}

func (_c *Client_GetHostnameDeploymentConnections_Call) RunAndReturn(run func(ctx context.Context) ([]hostname.LeaseIDConnection, error)) *Client_GetHostnameDeploymentConnections_Call {
	_c.Call.Return(run)
	return _c
}

// GetManifestGroup provides a mock function for the type Client
func (_mock *Client) GetManifestGroup(context1 context.Context, leaseID v1.LeaseID) (bool, v2beta2.ManifestGroup, error) {
	ret := _mock.Called(context1, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for GetManifestGroup")
	}

	var r0 bool
	var r1 v2beta2.ManifestGroup
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) (bool, v2beta2.ManifestGroup, error)); ok {
		return returnFunc(context1, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) bool); ok {
		r0 = returnFunc(context1, leaseID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) v2beta2.ManifestGroup); ok {
		r1 = returnFunc(context1, leaseID)
	} else {
		r1 = ret.Get(1).(v2beta2.ManifestGroup)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, v1.LeaseID) error); ok {
		r2 = returnFunc(context1, leaseID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Client_GetManifestGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManifestGroup'
type Client_GetManifestGroup_Call struct {
	*mock.Call
}

// GetManifestGroup is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
func (_e *Client_Expecter) GetManifestGroup(context1 interface{}, leaseID interface{}) *Client_GetManifestGroup_Call {
	return &Client_GetManifestGroup_Call{Call: _e.mock.On("GetManifestGroup", context1, leaseID)}
}

func (_c *Client_GetManifestGroup_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID)) *Client_GetManifestGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_GetManifestGroup_Call) Return(b bool, manifestGroup v2beta2.ManifestGroup, err error) *Client_GetManifestGroup_Call {
	_c.Call.Return(b, manifestGroup, err)
	return _c
}

func (_c *Client_GetManifestGroup_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID) (bool, v2beta2.ManifestGroup, error)) *Client_GetManifestGroup_Call {
	_c.Call.Return(run)
	return _c
}

// KubeVersion provides a mock function for the type Client
func (_mock *Client) KubeVersion() (*version.Info, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for KubeVersion")
	}

	var r0 *version.Info
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*version.Info, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *version.Info); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*version.Info)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_KubeVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KubeVersion'
type Client_KubeVersion_Call struct {
	*mock.Call
}

// KubeVersion is a helper method to define mock.On call
func (_e *Client_Expecter) KubeVersion() *Client_KubeVersion_Call {
	return &Client_KubeVersion_Call{Call: _e.mock.On("KubeVersion")}
}

func (_c *Client_KubeVersion_Call) Run(run func()) *Client_KubeVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_KubeVersion_Call) Return(info *version.Info, err error) *Client_KubeVersion_Call {
	_c.Call.Return(info, err)
	return _c
}

func (_c *Client_KubeVersion_Call) RunAndReturn(run func() (*version.Info, error)) *Client_KubeVersion_Call {
	_c.Call.Return(run)
	return _c
}

// LeaseEvents provides a mock function for the type Client
func (_mock *Client) LeaseEvents(context1 context.Context, leaseID v1.LeaseID, s string, b bool) (v1beta3.EventsWatcher, error) {
	ret := _mock.Called(context1, leaseID, s, b)

	if len(ret) == 0 {
		panic("no return value specified for LeaseEvents")
	}

	var r0 v1beta3.EventsWatcher
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool) (v1beta3.EventsWatcher, error)); ok {
		return returnFunc(context1, leaseID, s, b)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool) v1beta3.EventsWatcher); ok {
		r0 = returnFunc(context1, leaseID, s, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1beta3.EventsWatcher)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID, string, bool) error); ok {
		r1 = returnFunc(context1, leaseID, s, b)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_LeaseEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaseEvents'
type Client_LeaseEvents_Call struct {
	*mock.Call
}

// LeaseEvents is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
//   - s string
//   - b bool
func (_e *Client_Expecter) LeaseEvents(context1 interface{}, leaseID interface{}, s interface{}, b interface{}) *Client_LeaseEvents_Call {
	return &Client_LeaseEvents_Call{Call: _e.mock.On("LeaseEvents", context1, leaseID, s, b)}
}

func (_c *Client_LeaseEvents_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool)) *Client_LeaseEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Client_LeaseEvents_Call) Return(eventsWatcher v1beta3.EventsWatcher, err error) *Client_LeaseEvents_Call {
	_c.Call.Return(eventsWatcher, err)
	return _c
}

func (_c *Client_LeaseEvents_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool) (v1beta3.EventsWatcher, error)) *Client_LeaseEvents_Call {
	_c.Call.Return(run)
	return _c
}

// LeaseLogs provides a mock function for the type Client
func (_mock *Client) LeaseLogs(context1 context.Context, leaseID v1.LeaseID, s string, b bool, n *int64) ([]*v1beta3.ServiceLog, error) {
	ret := _mock.Called(context1, leaseID, s, b, n)

	if len(ret) == 0 {
		panic("no return value specified for LeaseLogs")
	}

	var r0 []*v1beta3.ServiceLog
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool, *int64) ([]*v1beta3.ServiceLog, error)); ok {
		return returnFunc(context1, leaseID, s, b, n)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool, *int64) []*v1beta3.ServiceLog); ok {
		r0 = returnFunc(context1, leaseID, s, b, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1beta3.ServiceLog)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID, string, bool, *int64) error); ok {
		r1 = returnFunc(context1, leaseID, s, b, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_LeaseLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaseLogs'
type Client_LeaseLogs_Call struct {
	*mock.Call
}

// LeaseLogs is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
//   - s string
//   - b bool
//   - n *int64
func (_e *Client_Expecter) LeaseLogs(context1 interface{}, leaseID interface{}, s interface{}, b interface{}, n interface{}) *Client_LeaseLogs_Call {
	return &Client_LeaseLogs_Call{Call: _e.mock.On("LeaseLogs", context1, leaseID, s, b, n)}
}

func (_c *Client_LeaseLogs_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool, n *int64)) *Client_LeaseLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		var arg4 *int64
		if args[4] != nil {
			arg4 = args[4].(*int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *Client_LeaseLogs_Call) Return(serviceLogs []*v1beta3.ServiceLog, err error) *Client_LeaseLogs_Call {
	_c.Call.Return(serviceLogs, err)
	return _c
}

func (_c *Client_LeaseLogs_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool, n *int64) ([]*v1beta3.ServiceLog, error)) *Client_LeaseLogs_Call {
	_c.Call.Return(run)
	return _c
}

// LeaseStatus provides a mock function for the type Client
func (_mock *Client) LeaseStatus(context1 context.Context, leaseID v1.LeaseID) (map[string]*rest.ServiceStatus, error) {
	ret := _mock.Called(context1, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for LeaseStatus")
	}

	var r0 map[string]*rest.ServiceStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) (map[string]*rest.ServiceStatus, error)); ok {
		return returnFunc(context1, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) map[string]*rest.ServiceStatus); ok {
		r0 = returnFunc(context1, leaseID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*rest.ServiceStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) error); ok {
		r1 = returnFunc(context1, leaseID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_LeaseStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaseStatus'
type Client_LeaseStatus_Call struct {
	*mock.Call
}

// LeaseStatus is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
func (_e *Client_Expecter) LeaseStatus(context1 interface{}, leaseID interface{}) *Client_LeaseStatus_Call {
	return &Client_LeaseStatus_Call{Call: _e.mock.On("LeaseStatus", context1, leaseID)}
}

func (_c *Client_LeaseStatus_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID)) *Client_LeaseStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_LeaseStatus_Call) Return(stringToServiceStatus map[string]*rest.ServiceStatus, err error) *Client_LeaseStatus_Call {
	_c.Call.Return(stringToServiceStatus, err)
	return _c
}

func (_c *Client_LeaseStatus_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID) (map[string]*rest.ServiceStatus, error)) *Client_LeaseStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ObserveHostnameState provides a mock function for the type Client
func (_mock *Client) ObserveHostnameState(ctx context.Context) (<-chan hostname.ResourceEvent, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObserveHostnameState")
	}

	var r0 <-chan hostname.ResourceEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan hostname.ResourceEvent, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan hostname.ResourceEvent); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan hostname.ResourceEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ObserveHostnameState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObserveHostnameState'
type Client_ObserveHostnameState_Call struct {
	*mock.Call
}

// ObserveHostnameState is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) ObserveHostnameState(ctx interface{}) *Client_ObserveHostnameState_Call {
	return &Client_ObserveHostnameState_Call{Call: _e.mock.On("ObserveHostnameState", ctx)}
}

func (_c *Client_ObserveHostnameState_Call) Run(run func(ctx context.Context)) *Client_ObserveHostnameState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_ObserveHostnameState_Call) Return(resourceEventCh <-chan hostname.ResourceEvent, err error) *Client_ObserveHostnameState_Call {
	_c.Call.Return(resourceEventCh, err)
	return _c
}

func (_c *Client_ObserveHostnameState_Call) RunAndReturn(run func(ctx context.Context) (<-chan hostname.ResourceEvent, error)) *Client_ObserveHostnameState_Call {
	_c.Call.Return(run)
	return _c
}

// ObserveIPState provides a mock function for the type Client
func (_mock *Client) ObserveIPState(ctx context.Context) (<-chan ip.ResourceEvent, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObserveIPState")
	}

	var r0 <-chan ip.ResourceEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan ip.ResourceEvent, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan ip.ResourceEvent); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan ip.ResourceEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ObserveIPState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObserveIPState'
type Client_ObserveIPState_Call struct {
	*mock.Call
}

// ObserveIPState is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) ObserveIPState(ctx interface{}) *Client_ObserveIPState_Call {
	return &Client_ObserveIPState_Call{Call: _e.mock.On("ObserveIPState", ctx)}
}

func (_c *Client_ObserveIPState_Call) Run(run func(ctx context.Context)) *Client_ObserveIPState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_ObserveIPState_Call) Return(resourceEventCh <-chan ip.ResourceEvent, err error) *Client_ObserveIPState_Call {
	_c.Call.Return(resourceEventCh, err)
	return _c
}

func (_c *Client_ObserveIPState_Call) RunAndReturn(run func(ctx context.Context) (<-chan ip.ResourceEvent, error)) *Client_ObserveIPState_Call {
	_c.Call.Return(run)
	return _c
}

// PurgeDeclaredHostname provides a mock function for the type Client
func (_mock *Client) PurgeDeclaredHostname(ctx context.Context, lID v1.LeaseID, hostname1 string) error {
	ret := _mock.Called(ctx, lID, hostname1)

	if len(ret) == 0 {
		panic("no return value specified for PurgeDeclaredHostname")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string) error); ok {
		r0 = returnFunc(ctx, lID, hostname1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_PurgeDeclaredHostname_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurgeDeclaredHostname'
type Client_PurgeDeclaredHostname_Call struct {
	*mock.Call
}

// PurgeDeclaredHostname is a helper method to define mock.On call
//   - ctx context.Context
//   - lID v1.LeaseID
//   - hostname1 string
func (_e *Client_Expecter) PurgeDeclaredHostname(ctx interface{}, lID interface{}, hostname1 interface{}) *Client_PurgeDeclaredHostname_Call {
	return &Client_PurgeDeclaredHostname_Call{Call: _e.mock.On("PurgeDeclaredHostname", ctx, lID, hostname1)}
}

func (_c *Client_PurgeDeclaredHostname_Call) Run(run func(ctx context.Context, lID v1.LeaseID, hostname1 string)) *Client_PurgeDeclaredHostname_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_PurgeDeclaredHostname_Call) Return(err error) *Client_PurgeDeclaredHostname_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_PurgeDeclaredHostname_Call) RunAndReturn(run func(ctx context.Context, lID v1.LeaseID, hostname1 string) error) *Client_PurgeDeclaredHostname_Call {
	_c.Call.Return(run)
	return _c
}

// PurgeDeclaredHostnames provides a mock function for the type Client
func (_mock *Client) PurgeDeclaredHostnames(ctx context.Context, lID v1.LeaseID) error {
	ret := _mock.Called(ctx, lID)

	if len(ret) == 0 {
		panic("no return value specified for PurgeDeclaredHostnames")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) error); ok {
		r0 = returnFunc(ctx, lID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_PurgeDeclaredHostnames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurgeDeclaredHostnames'
type Client_PurgeDeclaredHostnames_Call struct {
	*mock.Call
}

// PurgeDeclaredHostnames is a helper method to define mock.On call
//   - ctx context.Context
//   - lID v1.LeaseID
func (_e *Client_Expecter) PurgeDeclaredHostnames(ctx interface{}, lID interface{}) *Client_PurgeDeclaredHostnames_Call {
	return &Client_PurgeDeclaredHostnames_Call{Call: _e.mock.On("PurgeDeclaredHostnames", ctx, lID)}
}

func (_c *Client_PurgeDeclaredHostnames_Call) Run(run func(ctx context.Context, lID v1.LeaseID)) *Client_PurgeDeclaredHostnames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_PurgeDeclaredHostnames_Call) Return(err error) *Client_PurgeDeclaredHostnames_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_PurgeDeclaredHostnames_Call) RunAndReturn(run func(ctx context.Context, lID v1.LeaseID) error) *Client_PurgeDeclaredHostnames_Call {
	_c.Call.Return(run)
	return _c
}

// PurgeDeclaredIP provides a mock function for the type Client
func (_mock *Client) PurgeDeclaredIP(ctx context.Context, lID v1.LeaseID, serviceName string, externalPort uint32, proto v2beta3.ServiceProtocol) error {
	ret := _mock.Called(ctx, lID, serviceName, externalPort, proto)

	if len(ret) == 0 {
		panic("no return value specified for PurgeDeclaredIP")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, uint32, v2beta3.ServiceProtocol) error); ok {
		r0 = returnFunc(ctx, lID, serviceName, externalPort, proto)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_PurgeDeclaredIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurgeDeclaredIP'
type Client_PurgeDeclaredIP_Call struct {
	*mock.Call
}

// PurgeDeclaredIP is a helper method to define mock.On call
//   - ctx context.Context
//   - lID v1.LeaseID
//   - serviceName string
//   - externalPort uint32
//   - proto v2beta3.ServiceProtocol
func (_e *Client_Expecter) PurgeDeclaredIP(ctx interface{}, lID interface{}, serviceName interface{}, externalPort interface{}, proto interface{}) *Client_PurgeDeclaredIP_Call {
	return &Client_PurgeDeclaredIP_Call{Call: _e.mock.On("PurgeDeclaredIP", ctx, lID, serviceName, externalPort, proto)}
}

func (_c *Client_PurgeDeclaredIP_Call) Run(run func(ctx context.Context, lID v1.LeaseID, serviceName string, externalPort uint32, proto v2beta3.ServiceProtocol)) *Client_PurgeDeclaredIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 uint32
		if args[3] != nil {
			arg3 = args[3].(uint32)
		}
		var arg4 v2beta3.ServiceProtocol
		if args[4] != nil {
			arg4 = args[4].(v2beta3.ServiceProtocol)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *Client_PurgeDeclaredIP_Call) Return(err error) *Client_PurgeDeclaredIP_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_PurgeDeclaredIP_Call) RunAndReturn(run func(ctx context.Context, lID v1.LeaseID, serviceName string, externalPort uint32, proto v2beta3.ServiceProtocol) error) *Client_PurgeDeclaredIP_Call {
	_c.Call.Return(run)
	return _c
}

// PurgeDeclaredIPs provides a mock function for the type Client
func (_mock *Client) PurgeDeclaredIPs(ctx context.Context, lID v1.LeaseID) error {
	ret := _mock.Called(ctx, lID)

	if len(ret) == 0 {
		panic("no return value specified for PurgeDeclaredIPs")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) error); ok {
		r0 = returnFunc(ctx, lID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_PurgeDeclaredIPs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurgeDeclaredIPs'
type Client_PurgeDeclaredIPs_Call struct {
	*mock.Call
}

// PurgeDeclaredIPs is a helper method to define mock.On call
//   - ctx context.Context
//   - lID v1.LeaseID
func (_e *Client_Expecter) PurgeDeclaredIPs(ctx interface{}, lID interface{}) *Client_PurgeDeclaredIPs_Call {
	return &Client_PurgeDeclaredIPs_Call{Call: _e.mock.On("PurgeDeclaredIPs", ctx, lID)}
}

func (_c *Client_PurgeDeclaredIPs_Call) Run(run func(ctx context.Context, lID v1.LeaseID)) *Client_PurgeDeclaredIPs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_PurgeDeclaredIPs_Call) Return(err error) *Client_PurgeDeclaredIPs_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_PurgeDeclaredIPs_Call) RunAndReturn(run func(ctx context.Context, lID v1.LeaseID) error) *Client_PurgeDeclaredIPs_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveHostnameFromDeployment provides a mock function for the type Client
func (_mock *Client) RemoveHostnameFromDeployment(ctx context.Context, hostname1 string, leaseID v1.LeaseID, allowMissing bool) error {
	ret := _mock.Called(ctx, hostname1, leaseID, allowMissing)

	if len(ret) == 0 {
		panic("no return value specified for RemoveHostnameFromDeployment")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, v1.LeaseID, bool) error); ok {
		r0 = returnFunc(ctx, hostname1, leaseID, allowMissing)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_RemoveHostnameFromDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveHostnameFromDeployment'
type Client_RemoveHostnameFromDeployment_Call struct {
	*mock.Call
}

// RemoveHostnameFromDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - hostname1 string
//   - leaseID v1.LeaseID
//   - allowMissing bool
func (_e *Client_Expecter) RemoveHostnameFromDeployment(ctx interface{}, hostname1 interface{}, leaseID interface{}, allowMissing interface{}) *Client_RemoveHostnameFromDeployment_Call {
	return &Client_RemoveHostnameFromDeployment_Call{Call: _e.mock.On("RemoveHostnameFromDeployment", ctx, hostname1, leaseID, allowMissing)}
}

func (_c *Client_RemoveHostnameFromDeployment_Call) Run(run func(ctx context.Context, hostname1 string, leaseID v1.LeaseID, allowMissing bool)) *Client_RemoveHostnameFromDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 v1.LeaseID
		if args[2] != nil {
			arg2 = args[2].(v1.LeaseID)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Client_RemoveHostnameFromDeployment_Call) Return(err error) *Client_RemoveHostnameFromDeployment_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_RemoveHostnameFromDeployment_Call) RunAndReturn(run func(ctx context.Context, hostname1 string, leaseID v1.LeaseID, allowMissing bool) error) *Client_RemoveHostnameFromDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// ServiceStatus provides a mock function for the type Client
func (_mock *Client) ServiceStatus(context1 context.Context, leaseID v1.LeaseID, s string) (*rest.ServiceStatus, error) {
	ret := _mock.Called(context1, leaseID, s)

	if len(ret) == 0 {
		panic("no return value specified for ServiceStatus")
	}

	var r0 *rest.ServiceStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string) (*rest.ServiceStatus, error)); ok {
		return returnFunc(context1, leaseID, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string) *rest.ServiceStatus); ok {
		r0 = returnFunc(context1, leaseID, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rest.ServiceStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID, string) error); ok {
		r1 = returnFunc(context1, leaseID, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ServiceStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceStatus'
type Client_ServiceStatus_Call struct {
	*mock.Call
}

// ServiceStatus is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
//   - s string
func (_e *Client_Expecter) ServiceStatus(context1 interface{}, leaseID interface{}, s interface{}) *Client_ServiceStatus_Call {
	return &Client_ServiceStatus_Call{Call: _e.mock.On("ServiceStatus", context1, leaseID, s)}
}

func (_c *Client_ServiceStatus_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID, s string)) *Client_ServiceStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_ServiceStatus_Call) Return(serviceStatus *rest.ServiceStatus, err error) *Client_ServiceStatus_Call {
	_c.Call.Return(serviceStatus, err)
	return _c
}

func (_c *Client_ServiceStatus_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID, s string) (*rest.ServiceStatus, error)) *Client_ServiceStatus_Call {
	_c.Call.Return(run)
	return _c
}

// TeardownLease provides a mock function for the type Client
func (_mock *Client) TeardownLease(context1 context.Context, leaseID v1.LeaseID) error {
	ret := _mock.Called(context1, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for TeardownLease")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) error); ok {
		r0 = returnFunc(context1, leaseID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_TeardownLease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TeardownLease'
type Client_TeardownLease_Call struct {
	*mock.Call
}

// TeardownLease is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
func (_e *Client_Expecter) TeardownLease(context1 interface{}, leaseID interface{}) *Client_TeardownLease_Call {
	return &Client_TeardownLease_Call{Call: _e.mock.On("TeardownLease", context1, leaseID)}
}

func (_c *Client_TeardownLease_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID)) *Client_TeardownLease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_TeardownLease_Call) Return(err error) *Client_TeardownLease_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_TeardownLease_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID) error) *Client_TeardownLease_Call {
	_c.Call.Return(run)
	return _c
}
