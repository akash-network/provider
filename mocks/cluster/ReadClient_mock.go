// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package cluster

import (
	"context"

	"github.com/akash-network/provider/cluster/types/v1beta3"
	"github.com/akash-network/provider/cluster/types/v1beta3/clients/hostname"
	"github.com/akash-network/provider/cluster/types/v1beta3/clients/ip"
	"github.com/akash-network/provider/pkg/apis/akash.network/v2beta2"
	mock "github.com/stretchr/testify/mock"
	"pkg.akt.dev/go/node/market/v1"
	"pkg.akt.dev/go/provider/client"
)

// NewReadClient creates a new instance of ReadClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewReadClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *ReadClient {
	mock := &ReadClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ReadClient is an autogenerated mock type for the ReadClient type
type ReadClient struct {
	mock.Mock
}

type ReadClient_Expecter struct {
	mock *mock.Mock
}

func (_m *ReadClient) EXPECT() *ReadClient_Expecter {
	return &ReadClient_Expecter{mock: &_m.Mock}
}

// AllHostnames provides a mock function for the type ReadClient
func (_mock *ReadClient) AllHostnames(context1 context.Context) ([]hostname.ActiveHostname, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for AllHostnames")
	}

	var r0 []hostname.ActiveHostname
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]hostname.ActiveHostname, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []hostname.ActiveHostname); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]hostname.ActiveHostname)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_AllHostnames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllHostnames'
type ReadClient_AllHostnames_Call struct {
	*mock.Call
}

// AllHostnames is a helper method to define mock.On call
//   - context1 context.Context
func (_e *ReadClient_Expecter) AllHostnames(context1 interface{}) *ReadClient_AllHostnames_Call {
	return &ReadClient_AllHostnames_Call{Call: _e.mock.On("AllHostnames", context1)}
}

func (_c *ReadClient_AllHostnames_Call) Run(run func(context1 context.Context)) *ReadClient_AllHostnames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ReadClient_AllHostnames_Call) Return(activeHostnames []hostname.ActiveHostname, err error) *ReadClient_AllHostnames_Call {
	_c.Call.Return(activeHostnames, err)
	return _c
}

func (_c *ReadClient_AllHostnames_Call) RunAndReturn(run func(context1 context.Context) ([]hostname.ActiveHostname, error)) *ReadClient_AllHostnames_Call {
	_c.Call.Return(run)
	return _c
}

// ForwardedPortStatus provides a mock function for the type ReadClient
func (_mock *ReadClient) ForwardedPortStatus(context1 context.Context, leaseID v1.LeaseID) (map[string][]rest.ForwardedPortStatus, error) {
	ret := _mock.Called(context1, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for ForwardedPortStatus")
	}

	var r0 map[string][]rest.ForwardedPortStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) (map[string][]rest.ForwardedPortStatus, error)); ok {
		return returnFunc(context1, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) map[string][]rest.ForwardedPortStatus); ok {
		r0 = returnFunc(context1, leaseID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]rest.ForwardedPortStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) error); ok {
		r1 = returnFunc(context1, leaseID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_ForwardedPortStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForwardedPortStatus'
type ReadClient_ForwardedPortStatus_Call struct {
	*mock.Call
}

// ForwardedPortStatus is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
func (_e *ReadClient_Expecter) ForwardedPortStatus(context1 interface{}, leaseID interface{}) *ReadClient_ForwardedPortStatus_Call {
	return &ReadClient_ForwardedPortStatus_Call{Call: _e.mock.On("ForwardedPortStatus", context1, leaseID)}
}

func (_c *ReadClient_ForwardedPortStatus_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID)) *ReadClient_ForwardedPortStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ReadClient_ForwardedPortStatus_Call) Return(stringToForwardedPortStatuss map[string][]rest.ForwardedPortStatus, err error) *ReadClient_ForwardedPortStatus_Call {
	_c.Call.Return(stringToForwardedPortStatuss, err)
	return _c
}

func (_c *ReadClient_ForwardedPortStatus_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID) (map[string][]rest.ForwardedPortStatus, error)) *ReadClient_ForwardedPortStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeclaredIPs provides a mock function for the type ReadClient
func (_mock *ReadClient) GetDeclaredIPs(ctx context.Context, leaseID v1.LeaseID) ([]v2beta2.ProviderLeasedIPSpec, error) {
	ret := _mock.Called(ctx, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for GetDeclaredIPs")
	}

	var r0 []v2beta2.ProviderLeasedIPSpec
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) ([]v2beta2.ProviderLeasedIPSpec, error)); ok {
		return returnFunc(ctx, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) []v2beta2.ProviderLeasedIPSpec); ok {
		r0 = returnFunc(ctx, leaseID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v2beta2.ProviderLeasedIPSpec)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) error); ok {
		r1 = returnFunc(ctx, leaseID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_GetDeclaredIPs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeclaredIPs'
type ReadClient_GetDeclaredIPs_Call struct {
	*mock.Call
}

// GetDeclaredIPs is a helper method to define mock.On call
//   - ctx context.Context
//   - leaseID v1.LeaseID
func (_e *ReadClient_Expecter) GetDeclaredIPs(ctx interface{}, leaseID interface{}) *ReadClient_GetDeclaredIPs_Call {
	return &ReadClient_GetDeclaredIPs_Call{Call: _e.mock.On("GetDeclaredIPs", ctx, leaseID)}
}

func (_c *ReadClient_GetDeclaredIPs_Call) Run(run func(ctx context.Context, leaseID v1.LeaseID)) *ReadClient_GetDeclaredIPs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ReadClient_GetDeclaredIPs_Call) Return(providerLeasedIPSpecs []v2beta2.ProviderLeasedIPSpec, err error) *ReadClient_GetDeclaredIPs_Call {
	_c.Call.Return(providerLeasedIPSpecs, err)
	return _c
}

func (_c *ReadClient_GetDeclaredIPs_Call) RunAndReturn(run func(ctx context.Context, leaseID v1.LeaseID) ([]v2beta2.ProviderLeasedIPSpec, error)) *ReadClient_GetDeclaredIPs_Call {
	_c.Call.Return(run)
	return _c
}

// GetHostnameDeploymentConnections provides a mock function for the type ReadClient
func (_mock *ReadClient) GetHostnameDeploymentConnections(ctx context.Context) ([]hostname.LeaseIDConnection, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetHostnameDeploymentConnections")
	}

	var r0 []hostname.LeaseIDConnection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]hostname.LeaseIDConnection, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []hostname.LeaseIDConnection); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]hostname.LeaseIDConnection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_GetHostnameDeploymentConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostnameDeploymentConnections'
type ReadClient_GetHostnameDeploymentConnections_Call struct {
	*mock.Call
}

// GetHostnameDeploymentConnections is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ReadClient_Expecter) GetHostnameDeploymentConnections(ctx interface{}) *ReadClient_GetHostnameDeploymentConnections_Call {
	return &ReadClient_GetHostnameDeploymentConnections_Call{Call: _e.mock.On("GetHostnameDeploymentConnections", ctx)}
}

func (_c *ReadClient_GetHostnameDeploymentConnections_Call) Run(run func(ctx context.Context)) *ReadClient_GetHostnameDeploymentConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ReadClient_GetHostnameDeploymentConnections_Call) Return(leaseIDConnections []hostname.LeaseIDConnection, err error) *ReadClient_GetHostnameDeploymentConnections_Call {
	_c.Call.Return(leaseIDConnections, err)
	return _c
}

func (_c *ReadClient_GetHostnameDeploymentConnections_Call) RunAndReturn(run func(ctx context.Context) ([]hostname.LeaseIDConnection, error)) *ReadClient_GetHostnameDeploymentConnections_Call {
	_c.Call.Return(run)
	return _c
}

// GetManifestGroup provides a mock function for the type ReadClient
func (_mock *ReadClient) GetManifestGroup(context1 context.Context, leaseID v1.LeaseID) (bool, v2beta2.ManifestGroup, error) {
	ret := _mock.Called(context1, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for GetManifestGroup")
	}

	var r0 bool
	var r1 v2beta2.ManifestGroup
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) (bool, v2beta2.ManifestGroup, error)); ok {
		return returnFunc(context1, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) bool); ok {
		r0 = returnFunc(context1, leaseID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) v2beta2.ManifestGroup); ok {
		r1 = returnFunc(context1, leaseID)
	} else {
		r1 = ret.Get(1).(v2beta2.ManifestGroup)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, v1.LeaseID) error); ok {
		r2 = returnFunc(context1, leaseID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// ReadClient_GetManifestGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManifestGroup'
type ReadClient_GetManifestGroup_Call struct {
	*mock.Call
}

// GetManifestGroup is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
func (_e *ReadClient_Expecter) GetManifestGroup(context1 interface{}, leaseID interface{}) *ReadClient_GetManifestGroup_Call {
	return &ReadClient_GetManifestGroup_Call{Call: _e.mock.On("GetManifestGroup", context1, leaseID)}
}

func (_c *ReadClient_GetManifestGroup_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID)) *ReadClient_GetManifestGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ReadClient_GetManifestGroup_Call) Return(b bool, manifestGroup v2beta2.ManifestGroup, err error) *ReadClient_GetManifestGroup_Call {
	_c.Call.Return(b, manifestGroup, err)
	return _c
}

func (_c *ReadClient_GetManifestGroup_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID) (bool, v2beta2.ManifestGroup, error)) *ReadClient_GetManifestGroup_Call {
	_c.Call.Return(run)
	return _c
}

// LeaseEvents provides a mock function for the type ReadClient
func (_mock *ReadClient) LeaseEvents(context1 context.Context, leaseID v1.LeaseID, s string, b bool) (v1beta3.EventsWatcher, error) {
	ret := _mock.Called(context1, leaseID, s, b)

	if len(ret) == 0 {
		panic("no return value specified for LeaseEvents")
	}

	var r0 v1beta3.EventsWatcher
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool) (v1beta3.EventsWatcher, error)); ok {
		return returnFunc(context1, leaseID, s, b)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool) v1beta3.EventsWatcher); ok {
		r0 = returnFunc(context1, leaseID, s, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1beta3.EventsWatcher)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID, string, bool) error); ok {
		r1 = returnFunc(context1, leaseID, s, b)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_LeaseEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaseEvents'
type ReadClient_LeaseEvents_Call struct {
	*mock.Call
}

// LeaseEvents is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
//   - s string
//   - b bool
func (_e *ReadClient_Expecter) LeaseEvents(context1 interface{}, leaseID interface{}, s interface{}, b interface{}) *ReadClient_LeaseEvents_Call {
	return &ReadClient_LeaseEvents_Call{Call: _e.mock.On("LeaseEvents", context1, leaseID, s, b)}
}

func (_c *ReadClient_LeaseEvents_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool)) *ReadClient_LeaseEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ReadClient_LeaseEvents_Call) Return(eventsWatcher v1beta3.EventsWatcher, err error) *ReadClient_LeaseEvents_Call {
	_c.Call.Return(eventsWatcher, err)
	return _c
}

func (_c *ReadClient_LeaseEvents_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool) (v1beta3.EventsWatcher, error)) *ReadClient_LeaseEvents_Call {
	_c.Call.Return(run)
	return _c
}

// LeaseLogs provides a mock function for the type ReadClient
func (_mock *ReadClient) LeaseLogs(context1 context.Context, leaseID v1.LeaseID, s string, b bool, n *int64) ([]*v1beta3.ServiceLog, error) {
	ret := _mock.Called(context1, leaseID, s, b, n)

	if len(ret) == 0 {
		panic("no return value specified for LeaseLogs")
	}

	var r0 []*v1beta3.ServiceLog
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool, *int64) ([]*v1beta3.ServiceLog, error)); ok {
		return returnFunc(context1, leaseID, s, b, n)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string, bool, *int64) []*v1beta3.ServiceLog); ok {
		r0 = returnFunc(context1, leaseID, s, b, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1beta3.ServiceLog)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID, string, bool, *int64) error); ok {
		r1 = returnFunc(context1, leaseID, s, b, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_LeaseLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaseLogs'
type ReadClient_LeaseLogs_Call struct {
	*mock.Call
}

// LeaseLogs is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
//   - s string
//   - b bool
//   - n *int64
func (_e *ReadClient_Expecter) LeaseLogs(context1 interface{}, leaseID interface{}, s interface{}, b interface{}, n interface{}) *ReadClient_LeaseLogs_Call {
	return &ReadClient_LeaseLogs_Call{Call: _e.mock.On("LeaseLogs", context1, leaseID, s, b, n)}
}

func (_c *ReadClient_LeaseLogs_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool, n *int64)) *ReadClient_LeaseLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		var arg4 *int64
		if args[4] != nil {
			arg4 = args[4].(*int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *ReadClient_LeaseLogs_Call) Return(serviceLogs []*v1beta3.ServiceLog, err error) *ReadClient_LeaseLogs_Call {
	_c.Call.Return(serviceLogs, err)
	return _c
}

func (_c *ReadClient_LeaseLogs_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID, s string, b bool, n *int64) ([]*v1beta3.ServiceLog, error)) *ReadClient_LeaseLogs_Call {
	_c.Call.Return(run)
	return _c
}

// LeaseStatus provides a mock function for the type ReadClient
func (_mock *ReadClient) LeaseStatus(context1 context.Context, leaseID v1.LeaseID) (map[string]*rest.ServiceStatus, error) {
	ret := _mock.Called(context1, leaseID)

	if len(ret) == 0 {
		panic("no return value specified for LeaseStatus")
	}

	var r0 map[string]*rest.ServiceStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) (map[string]*rest.ServiceStatus, error)); ok {
		return returnFunc(context1, leaseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID) map[string]*rest.ServiceStatus); ok {
		r0 = returnFunc(context1, leaseID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*rest.ServiceStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID) error); ok {
		r1 = returnFunc(context1, leaseID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_LeaseStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaseStatus'
type ReadClient_LeaseStatus_Call struct {
	*mock.Call
}

// LeaseStatus is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
func (_e *ReadClient_Expecter) LeaseStatus(context1 interface{}, leaseID interface{}) *ReadClient_LeaseStatus_Call {
	return &ReadClient_LeaseStatus_Call{Call: _e.mock.On("LeaseStatus", context1, leaseID)}
}

func (_c *ReadClient_LeaseStatus_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID)) *ReadClient_LeaseStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ReadClient_LeaseStatus_Call) Return(stringToServiceStatus map[string]*rest.ServiceStatus, err error) *ReadClient_LeaseStatus_Call {
	_c.Call.Return(stringToServiceStatus, err)
	return _c
}

func (_c *ReadClient_LeaseStatus_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID) (map[string]*rest.ServiceStatus, error)) *ReadClient_LeaseStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ObserveHostnameState provides a mock function for the type ReadClient
func (_mock *ReadClient) ObserveHostnameState(ctx context.Context) (<-chan hostname.ResourceEvent, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObserveHostnameState")
	}

	var r0 <-chan hostname.ResourceEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan hostname.ResourceEvent, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan hostname.ResourceEvent); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan hostname.ResourceEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_ObserveHostnameState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObserveHostnameState'
type ReadClient_ObserveHostnameState_Call struct {
	*mock.Call
}

// ObserveHostnameState is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ReadClient_Expecter) ObserveHostnameState(ctx interface{}) *ReadClient_ObserveHostnameState_Call {
	return &ReadClient_ObserveHostnameState_Call{Call: _e.mock.On("ObserveHostnameState", ctx)}
}

func (_c *ReadClient_ObserveHostnameState_Call) Run(run func(ctx context.Context)) *ReadClient_ObserveHostnameState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ReadClient_ObserveHostnameState_Call) Return(resourceEventCh <-chan hostname.ResourceEvent, err error) *ReadClient_ObserveHostnameState_Call {
	_c.Call.Return(resourceEventCh, err)
	return _c
}

func (_c *ReadClient_ObserveHostnameState_Call) RunAndReturn(run func(ctx context.Context) (<-chan hostname.ResourceEvent, error)) *ReadClient_ObserveHostnameState_Call {
	_c.Call.Return(run)
	return _c
}

// ObserveIPState provides a mock function for the type ReadClient
func (_mock *ReadClient) ObserveIPState(ctx context.Context) (<-chan ip.ResourceEvent, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObserveIPState")
	}

	var r0 <-chan ip.ResourceEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (<-chan ip.ResourceEvent, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) <-chan ip.ResourceEvent); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan ip.ResourceEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_ObserveIPState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObserveIPState'
type ReadClient_ObserveIPState_Call struct {
	*mock.Call
}

// ObserveIPState is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ReadClient_Expecter) ObserveIPState(ctx interface{}) *ReadClient_ObserveIPState_Call {
	return &ReadClient_ObserveIPState_Call{Call: _e.mock.On("ObserveIPState", ctx)}
}

func (_c *ReadClient_ObserveIPState_Call) Run(run func(ctx context.Context)) *ReadClient_ObserveIPState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ReadClient_ObserveIPState_Call) Return(resourceEventCh <-chan ip.ResourceEvent, err error) *ReadClient_ObserveIPState_Call {
	_c.Call.Return(resourceEventCh, err)
	return _c
}

func (_c *ReadClient_ObserveIPState_Call) RunAndReturn(run func(ctx context.Context) (<-chan ip.ResourceEvent, error)) *ReadClient_ObserveIPState_Call {
	_c.Call.Return(run)
	return _c
}

// ServiceStatus provides a mock function for the type ReadClient
func (_mock *ReadClient) ServiceStatus(context1 context.Context, leaseID v1.LeaseID, s string) (*rest.ServiceStatus, error) {
	ret := _mock.Called(context1, leaseID, s)

	if len(ret) == 0 {
		panic("no return value specified for ServiceStatus")
	}

	var r0 *rest.ServiceStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string) (*rest.ServiceStatus, error)); ok {
		return returnFunc(context1, leaseID, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, v1.LeaseID, string) *rest.ServiceStatus); ok {
		r0 = returnFunc(context1, leaseID, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rest.ServiceStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, v1.LeaseID, string) error); ok {
		r1 = returnFunc(context1, leaseID, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ReadClient_ServiceStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceStatus'
type ReadClient_ServiceStatus_Call struct {
	*mock.Call
}

// ServiceStatus is a helper method to define mock.On call
//   - context1 context.Context
//   - leaseID v1.LeaseID
//   - s string
func (_e *ReadClient_Expecter) ServiceStatus(context1 interface{}, leaseID interface{}, s interface{}) *ReadClient_ServiceStatus_Call {
	return &ReadClient_ServiceStatus_Call{Call: _e.mock.On("ServiceStatus", context1, leaseID, s)}
}

func (_c *ReadClient_ServiceStatus_Call) Run(run func(context1 context.Context, leaseID v1.LeaseID, s string)) *ReadClient_ServiceStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 v1.LeaseID
		if args[1] != nil {
			arg1 = args[1].(v1.LeaseID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ReadClient_ServiceStatus_Call) Return(serviceStatus *rest.ServiceStatus, err error) *ReadClient_ServiceStatus_Call {
	_c.Call.Return(serviceStatus, err)
	return _c
}

func (_c *ReadClient_ServiceStatus_Call) RunAndReturn(run func(context1 context.Context, leaseID v1.LeaseID, s string) (*rest.ServiceStatus, error)) *ReadClient_ServiceStatus_Call {
	_c.Call.Return(run)
	return _c
}
